{"ast":null,"code":"let parser = require('postcss-value-parser');\nlet list = require('postcss').list;\nlet uniq = require('../utils').uniq;\nlet escapeRegexp = require('../utils').escapeRegexp;\nlet splitSelector = require('../utils').splitSelector;\nfunction convert(value) {\n  if (value && value.length === 2 && value[0] === 'span' && parseInt(value[1], 10) > 0) {\n    return [false, parseInt(value[1], 10)];\n  }\n  if (value && value.length === 1 && parseInt(value[0], 10) > 0) {\n    return [parseInt(value[0], 10), false];\n  }\n  return [false, false];\n}\nexports.translate = translate;\nfunction translate(values, startIndex, endIndex) {\n  let startValue = values[startIndex];\n  let endValue = values[endIndex];\n  if (!startValue) {\n    return [false, false];\n  }\n  let [start, spanStart] = convert(startValue);\n  let [end, spanEnd] = convert(endValue);\n  if (start && !endValue) {\n    return [start, false];\n  }\n  if (spanStart && end) {\n    return [end - spanStart, spanStart];\n  }\n  if (start && spanEnd) {\n    return [start, spanEnd];\n  }\n  if (start && end) {\n    return [start, end - start];\n  }\n  return [false, false];\n}\nexports.parse = parse;\nfunction parse(decl) {\n  let node = parser(decl.value);\n  let values = [];\n  let current = 0;\n  values[current] = [];\n  for (let i of node.nodes) {\n    if (i.type === 'div') {\n      current += 1;\n      values[current] = [];\n    } else if (i.type === 'word') {\n      values[current].push(i.value);\n    }\n  }\n  return values;\n}\nexports.insertDecl = insertDecl;\nfunction insertDecl(decl, prop, value) {\n  if (value && !decl.parent.some(i => i.prop === `-ms-${prop}`)) {\n    decl.cloneBefore({\n      prop: `-ms-${prop}`,\n      value: value.toString()\n    });\n  }\n}\n\n// Track transforms\n\nexports.prefixTrackProp = prefixTrackProp;\nfunction prefixTrackProp(_ref) {\n  let {\n    prop,\n    prefix\n  } = _ref;\n  return prefix + prop.replace('template-', '');\n}\nfunction transformRepeat(_ref2, _ref3) {\n  let {\n    nodes\n  } = _ref2;\n  let {\n    gap\n  } = _ref3;\n  let {\n    count,\n    size\n  } = nodes.reduce((result, node) => {\n    if (node.type === 'div' && node.value === ',') {\n      result.key = 'size';\n    } else {\n      result[result.key].push(parser.stringify(node));\n    }\n    return result;\n  }, {\n    key: 'count',\n    size: [],\n    count: []\n  });\n\n  // insert gap values\n  if (gap) {\n    size = size.filter(i => i.trim());\n    let val = [];\n    for (let i = 1; i <= count; i++) {\n      size.forEach((item, index) => {\n        if (index > 0 || i > 1) {\n          val.push(gap);\n        }\n        val.push(item);\n      });\n    }\n    return val.join(' ');\n  }\n  return `(${size.join('')})[${count.join('')}]`;\n}\nexports.prefixTrackValue = prefixTrackValue;\nfunction prefixTrackValue(_ref4) {\n  let {\n    value,\n    gap\n  } = _ref4;\n  let result = parser(value).nodes.reduce((nodes, node) => {\n    if (node.type === 'function' && node.value === 'repeat') {\n      return nodes.concat({\n        type: 'word',\n        value: transformRepeat(node, {\n          gap\n        })\n      });\n    }\n    if (gap && node.type === 'space') {\n      return nodes.concat({\n        type: 'space',\n        value: ' '\n      }, {\n        type: 'word',\n        value: gap\n      }, node);\n    }\n    return nodes.concat(node);\n  }, []);\n  return parser.stringify(result);\n}\n\n// Parse grid-template-areas\n\nlet DOTS = /^\\.+$/;\nfunction track(start, end) {\n  return {\n    start,\n    end,\n    span: end - start\n  };\n}\nfunction getColumns(line) {\n  return line.trim().split(/\\s+/g);\n}\nexports.parseGridAreas = parseGridAreas;\nfunction parseGridAreas(_ref5) {\n  let {\n    rows,\n    gap\n  } = _ref5;\n  return rows.reduce((areas, line, rowIndex) => {\n    if (gap.row) rowIndex *= 2;\n    if (line.trim() === '') return areas;\n    getColumns(line).forEach((area, columnIndex) => {\n      if (DOTS.test(area)) return;\n      if (gap.column) columnIndex *= 2;\n      if (typeof areas[area] === 'undefined') {\n        areas[area] = {\n          column: track(columnIndex + 1, columnIndex + 2),\n          row: track(rowIndex + 1, rowIndex + 2)\n        };\n      } else {\n        let {\n          column,\n          row\n        } = areas[area];\n        column.start = Math.min(column.start, columnIndex + 1);\n        column.end = Math.max(column.end, columnIndex + 2);\n        column.span = column.end - column.start;\n        row.start = Math.min(row.start, rowIndex + 1);\n        row.end = Math.max(row.end, rowIndex + 2);\n        row.span = row.end - row.start;\n      }\n    });\n    return areas;\n  }, {});\n}\n\n// Parse grid-template\n\nfunction testTrack(node) {\n  return node.type === 'word' && /^\\[.+]$/.test(node.value);\n}\nfunction verifyRowSize(result) {\n  if (result.areas.length > result.rows.length) {\n    result.rows.push('auto');\n  }\n  return result;\n}\nexports.parseTemplate = parseTemplate;\nfunction parseTemplate(_ref6) {\n  let {\n    decl,\n    gap\n  } = _ref6;\n  let gridTemplate = parser(decl.value).nodes.reduce((result, node) => {\n    let {\n      type,\n      value\n    } = node;\n    if (testTrack(node) || type === 'space') return result;\n\n    // area\n    if (type === 'string') {\n      result = verifyRowSize(result);\n      result.areas.push(value);\n    }\n\n    // values and function\n    if (type === 'word' || type === 'function') {\n      result[result.key].push(parser.stringify(node));\n    }\n\n    // divider(/)\n    if (type === 'div' && value === '/') {\n      result.key = 'columns';\n      result = verifyRowSize(result);\n    }\n    return result;\n  }, {\n    key: 'rows',\n    columns: [],\n    rows: [],\n    areas: []\n  });\n  return {\n    areas: parseGridAreas({\n      rows: gridTemplate.areas,\n      gap\n    }),\n    columns: prefixTrackValue({\n      value: gridTemplate.columns.join(' '),\n      gap: gap.column\n    }),\n    rows: prefixTrackValue({\n      value: gridTemplate.rows.join(' '),\n      gap: gap.row\n    })\n  };\n}\n\n// Insert parsed grid areas\n\n/**\n * Get an array of -ms- prefixed props and values\n * @param  {Object} [area] area object with column and row data\n * @param  {Boolean} [addRowSpan] should we add grid-column-row value?\n * @param  {Boolean} [addColumnSpan] should we add grid-column-span value?\n * @return {Array<Object>}\n */\nfunction getMSDecls(area) {\n  let addRowSpan = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  let addColumnSpan = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  let result = [{\n    prop: '-ms-grid-row',\n    value: String(area.row.start)\n  }];\n  if (area.row.span > 1 || addRowSpan) {\n    result.push({\n      prop: '-ms-grid-row-span',\n      value: String(area.row.span)\n    });\n  }\n  result.push({\n    prop: '-ms-grid-column',\n    value: String(area.column.start)\n  });\n  if (area.column.span > 1 || addColumnSpan) {\n    result.push({\n      prop: '-ms-grid-column-span',\n      value: String(area.column.span)\n    });\n  }\n  return result;\n}\nfunction getParentMedia(parent) {\n  if (parent.type === 'atrule' && parent.name === 'media') {\n    return parent;\n  }\n  if (!parent.parent) {\n    return false;\n  }\n  return getParentMedia(parent.parent);\n}\n\n/**\n * change selectors for rules with duplicate grid-areas.\n * @param  {Array<Rule>} rules\n * @param  {Array<String>} templateSelectors\n * @return {Array<Rule>} rules with changed selectors\n */\nfunction changeDuplicateAreaSelectors(ruleSelectors, templateSelectors) {\n  ruleSelectors = ruleSelectors.map(selector => {\n    let selectorBySpace = list.space(selector);\n    let selectorByComma = list.comma(selector);\n    if (selectorBySpace.length > selectorByComma.length) {\n      selector = selectorBySpace.slice(-1).join('');\n    }\n    return selector;\n  });\n  return ruleSelectors.map(ruleSelector => {\n    let newSelector = templateSelectors.map((tplSelector, index) => {\n      let space = index === 0 ? '' : ' ';\n      return `${space}${tplSelector} > ${ruleSelector}`;\n    });\n    return newSelector;\n  });\n}\n\n/**\n * check if selector of rules are equal\n * @param  {Rule} ruleA\n * @param  {Rule} ruleB\n * @return {Boolean}\n */\nfunction selectorsEqual(ruleA, ruleB) {\n  return ruleA.selectors.some(sel => {\n    return ruleB.selectors.includes(sel);\n  });\n}\n\n/**\n * Parse data from all grid-template(-areas) declarations\n * @param  {Root} css css root\n * @return {Object} parsed data\n */\nfunction parseGridTemplatesData(css) {\n  let parsed = [];\n\n  // we walk through every grid-template(-areas) declaration and store\n  // data with the same area names inside the item\n  css.walkDecls(/grid-template(-areas)?$/, d => {\n    let rule = d.parent;\n    let media = getParentMedia(rule);\n    let gap = getGridGap(d);\n    let inheritedGap = inheritGridGap(d, gap);\n    let {\n      areas\n    } = parseTemplate({\n      decl: d,\n      gap: inheritedGap || gap\n    });\n    let areaNames = Object.keys(areas);\n\n    // skip node if it doesn't have areas\n    if (areaNames.length === 0) {\n      return true;\n    }\n\n    // check parsed array for item that include the same area names\n    // return index of that item\n    let index = parsed.reduce((acc, _ref7, idx) => {\n      let {\n        allAreas\n      } = _ref7;\n      let hasAreas = allAreas && areaNames.some(area => allAreas.includes(area));\n      return hasAreas ? idx : acc;\n    }, null);\n    if (index !== null) {\n      // index is found, add the grid-template data to that item\n      let {\n        allAreas,\n        rules\n      } = parsed[index];\n\n      // check if rule has no duplicate area names\n      let hasNoDuplicates = rules.some(r => {\n        return r.hasDuplicates === false && selectorsEqual(r, rule);\n      });\n      let duplicatesFound = false;\n\n      // check need to gather all duplicate area names\n      let duplicateAreaNames = rules.reduce((acc, r) => {\n        if (!r.params && selectorsEqual(r, rule)) {\n          duplicatesFound = true;\n          return r.duplicateAreaNames;\n        }\n        if (!duplicatesFound) {\n          areaNames.forEach(name => {\n            if (r.areas[name]) {\n              acc.push(name);\n            }\n          });\n        }\n        return uniq(acc);\n      }, []);\n\n      // update grid-row/column-span values for areas with duplicate\n      // area names. @see #1084 and #1146\n      rules.forEach(r => {\n        areaNames.forEach(name => {\n          let area = r.areas[name];\n          if (area && area.row.span !== areas[name].row.span) {\n            areas[name].row.updateSpan = true;\n          }\n          if (area && area.column.span !== areas[name].column.span) {\n            areas[name].column.updateSpan = true;\n          }\n        });\n      });\n      parsed[index].allAreas = uniq([...allAreas, ...areaNames]);\n      parsed[index].rules.push({\n        hasDuplicates: !hasNoDuplicates,\n        params: media.params,\n        selectors: rule.selectors,\n        node: rule,\n        duplicateAreaNames,\n        areas\n      });\n    } else {\n      // index is NOT found, push the new item to the parsed array\n      parsed.push({\n        allAreas: areaNames,\n        areasCount: 0,\n        rules: [{\n          hasDuplicates: false,\n          duplicateRules: [],\n          params: media.params,\n          selectors: rule.selectors,\n          node: rule,\n          duplicateAreaNames: [],\n          areas\n        }]\n      });\n    }\n    return undefined;\n  });\n  return parsed;\n}\n\n/**\n * insert prefixed grid-area declarations\n * @param  {Root}  css css root\n * @param  {Function} isDisabled check if the rule is disabled\n * @return {void}\n */\nexports.insertAreas = insertAreas;\nfunction insertAreas(css, isDisabled) {\n  // parse grid-template declarations\n  let gridTemplatesData = parseGridTemplatesData(css);\n\n  // return undefined if no declarations found\n  if (gridTemplatesData.length === 0) {\n    return undefined;\n  }\n\n  // we need to store the rules that we will insert later\n  let rulesToInsert = {};\n  css.walkDecls('grid-area', gridArea => {\n    let gridAreaRule = gridArea.parent;\n    let hasPrefixedRow = gridAreaRule.first.prop === '-ms-grid-row';\n    let gridAreaMedia = getParentMedia(gridAreaRule);\n    if (isDisabled(gridArea)) {\n      return undefined;\n    }\n    let gridAreaRuleIndex = css.index(gridAreaMedia || gridAreaRule);\n    let value = gridArea.value;\n    // found the data that matches grid-area identifier\n    let data = gridTemplatesData.filter(d => d.allAreas.includes(value))[0];\n    if (!data) {\n      return true;\n    }\n    let lastArea = data.allAreas[data.allAreas.length - 1];\n    let selectorBySpace = list.space(gridAreaRule.selector);\n    let selectorByComma = list.comma(gridAreaRule.selector);\n    let selectorIsComplex = selectorBySpace.length > 1 && selectorBySpace.length > selectorByComma.length;\n\n    // prevent doubling of prefixes\n    if (hasPrefixedRow) {\n      return false;\n    }\n\n    // create the empty object with the key as the last area name\n    // e.g if we have templates with \"a b c\" values, \"c\" will be the last area\n    if (!rulesToInsert[lastArea]) {\n      rulesToInsert[lastArea] = {};\n    }\n    let lastRuleIsSet = false;\n\n    // walk through every grid-template rule data\n    for (let rule of data.rules) {\n      let area = rule.areas[value];\n      let hasDuplicateName = rule.duplicateAreaNames.includes(value);\n\n      // if we can't find the area name, update lastRule and continue\n      if (!area) {\n        let lastRule = rulesToInsert[lastArea].lastRule;\n        let lastRuleIndex;\n        if (lastRule) {\n          lastRuleIndex = css.index(lastRule);\n        } else {\n          /* c8 ignore next 2 */\n          lastRuleIndex = -1;\n        }\n        if (gridAreaRuleIndex > lastRuleIndex) {\n          rulesToInsert[lastArea].lastRule = gridAreaMedia || gridAreaRule;\n        }\n        continue;\n      }\n\n      // for grid-templates inside media rule we need to create empty\n      // array to push prefixed grid-area rules later\n      if (rule.params && !rulesToInsert[lastArea][rule.params]) {\n        rulesToInsert[lastArea][rule.params] = [];\n      }\n      if ((!rule.hasDuplicates || !hasDuplicateName) && !rule.params) {\n        // grid-template has no duplicates and not inside media rule\n\n        getMSDecls(area, false, false).reverse().forEach(i => gridAreaRule.prepend(Object.assign(i, {\n          raws: {\n            between: gridArea.raws.between\n          }\n        })));\n        rulesToInsert[lastArea].lastRule = gridAreaRule;\n        lastRuleIsSet = true;\n      } else if (rule.hasDuplicates && !rule.params && !selectorIsComplex) {\n        // grid-template has duplicates and not inside media rule\n        let cloned = gridAreaRule.clone();\n        cloned.removeAll();\n        getMSDecls(area, area.row.updateSpan, area.column.updateSpan).reverse().forEach(i => cloned.prepend(Object.assign(i, {\n          raws: {\n            between: gridArea.raws.between\n          }\n        })));\n        cloned.selectors = changeDuplicateAreaSelectors(cloned.selectors, rule.selectors);\n        if (rulesToInsert[lastArea].lastRule) {\n          rulesToInsert[lastArea].lastRule.after(cloned);\n        }\n        rulesToInsert[lastArea].lastRule = cloned;\n        lastRuleIsSet = true;\n      } else if (rule.hasDuplicates && !rule.params && selectorIsComplex && gridAreaRule.selector.includes(rule.selectors[0])) {\n        // grid-template has duplicates and not inside media rule\n        // and the selector is complex\n        gridAreaRule.walkDecls(/-ms-grid-(row|column)/, d => d.remove());\n        getMSDecls(area, area.row.updateSpan, area.column.updateSpan).reverse().forEach(i => gridAreaRule.prepend(Object.assign(i, {\n          raws: {\n            between: gridArea.raws.between\n          }\n        })));\n      } else if (rule.params) {\n        // grid-template is inside media rule\n        // if we're inside media rule, we need to store prefixed rules\n        // inside rulesToInsert object to be able to preserve the order of media\n        // rules and merge them easily\n        let cloned = gridAreaRule.clone();\n        cloned.removeAll();\n        getMSDecls(area, area.row.updateSpan, area.column.updateSpan).reverse().forEach(i => cloned.prepend(Object.assign(i, {\n          raws: {\n            between: gridArea.raws.between\n          }\n        })));\n        if (rule.hasDuplicates && hasDuplicateName) {\n          cloned.selectors = changeDuplicateAreaSelectors(cloned.selectors, rule.selectors);\n        }\n        cloned.raws = rule.node.raws;\n        if (css.index(rule.node.parent) > gridAreaRuleIndex) {\n          // append the prefixed rules right inside media rule\n          // with grid-template\n          rule.node.parent.append(cloned);\n        } else {\n          // store the rule to insert later\n          rulesToInsert[lastArea][rule.params].push(cloned);\n        }\n\n        // set new rule as last rule ONLY if we didn't set lastRule for\n        // this grid-area before\n        if (!lastRuleIsSet) {\n          rulesToInsert[lastArea].lastRule = gridAreaMedia || gridAreaRule;\n        }\n      }\n    }\n    return undefined;\n  });\n\n  // append stored rules inside the media rules\n  Object.keys(rulesToInsert).forEach(area => {\n    let data = rulesToInsert[area];\n    let lastRule = data.lastRule;\n    Object.keys(data).reverse().filter(p => p !== 'lastRule').forEach(params => {\n      if (data[params].length > 0 && lastRule) {\n        lastRule.after({\n          name: 'media',\n          params\n        });\n        lastRule.next().append(data[params]);\n      }\n    });\n  });\n  return undefined;\n}\n\n/**\n * Warn user if grid area identifiers are not found\n * @param  {Object} areas\n * @param  {Declaration} decl\n * @param  {Result} result\n * @return {void}\n */\nexports.warnMissedAreas = warnMissedAreas;\nfunction warnMissedAreas(areas, decl, result) {\n  let missed = Object.keys(areas);\n  decl.root().walkDecls('grid-area', gridArea => {\n    missed = missed.filter(e => e !== gridArea.value);\n  });\n  if (missed.length > 0) {\n    decl.warn(result, 'Can not find grid areas: ' + missed.join(', '));\n  }\n  return undefined;\n}\n\n/**\n * compare selectors with grid-area rule and grid-template rule\n * show warning if grid-template selector is not found\n * (this function used for grid-area rule)\n * @param  {Declaration} decl\n * @param  {Result} result\n * @return {void}\n */\nexports.warnTemplateSelectorNotFound = warnTemplateSelectorNotFound;\nfunction warnTemplateSelectorNotFound(decl, result) {\n  let rule = decl.parent;\n  let root = decl.root();\n  let duplicatesFound = false;\n\n  // slice selector array. Remove the last part (for comparison)\n  let slicedSelectorArr = list.space(rule.selector).filter(str => str !== '>').slice(0, -1);\n\n  // we need to compare only if selector is complex.\n  // e.g '.grid-cell' is simple, but '.parent > .grid-cell' is complex\n  if (slicedSelectorArr.length > 0) {\n    let gridTemplateFound = false;\n    let foundAreaSelector = null;\n    root.walkDecls(/grid-template(-areas)?$/, d => {\n      let parent = d.parent;\n      let templateSelectors = parent.selectors;\n      let {\n        areas\n      } = parseTemplate({\n        decl: d,\n        gap: getGridGap(d)\n      });\n      let hasArea = areas[decl.value];\n\n      // find the the matching selectors\n      for (let tplSelector of templateSelectors) {\n        if (gridTemplateFound) {\n          break;\n        }\n        let tplSelectorArr = list.space(tplSelector).filter(str => str !== '>');\n        gridTemplateFound = tplSelectorArr.every((item, idx) => item === slicedSelectorArr[idx]);\n      }\n      if (gridTemplateFound || !hasArea) {\n        return true;\n      }\n      if (!foundAreaSelector) {\n        foundAreaSelector = parent.selector;\n      }\n\n      // if we found the duplicate area with different selector\n      if (foundAreaSelector && foundAreaSelector !== parent.selector) {\n        duplicatesFound = true;\n      }\n      return undefined;\n    });\n\n    // warn user if we didn't find template\n    if (!gridTemplateFound && duplicatesFound) {\n      decl.warn(result, 'Autoprefixer cannot find a grid-template ' + `containing the duplicate grid-area \"${decl.value}\" ` + `with full selector matching: ${slicedSelectorArr.join(' ')}`);\n    }\n  }\n}\n\n/**\n * warn user if both grid-area and grid-(row|column)\n * declarations are present in the same rule\n * @param  {Declaration} decl\n * @param  {Result} result\n * @return {void}\n */\nexports.warnIfGridRowColumnExists = warnIfGridRowColumnExists;\nfunction warnIfGridRowColumnExists(decl, result) {\n  let rule = decl.parent;\n  let decls = [];\n  rule.walkDecls(/^grid-(row|column)/, d => {\n    if (!d.prop.endsWith('-end') && !d.value.startsWith('span') && !d.prop.endsWith('-gap')) {\n      decls.push(d);\n    }\n  });\n  if (decls.length > 0) {\n    decls.forEach(d => {\n      d.warn(result, 'You already have a grid-area declaration present in the rule. ' + `You should use either grid-area or ${d.prop}, not both`);\n    });\n  }\n  return undefined;\n}\n\n// Gap utils\n\nexports.getGridGap = getGridGap;\nfunction getGridGap(decl) {\n  let gap = {};\n\n  // try to find gap\n  let testGap = /^(grid-)?((row|column)-)?gap$/;\n  decl.parent.walkDecls(testGap, _ref8 => {\n    let {\n      prop,\n      value\n    } = _ref8;\n    if (/^(grid-)?gap$/.test(prop)) {\n      let [row,, column] = parser(value).nodes;\n      gap.row = row && parser.stringify(row);\n      gap.column = column ? parser.stringify(column) : gap.row;\n    }\n    if (/^(grid-)?row-gap$/.test(prop)) gap.row = value;\n    if (/^(grid-)?column-gap$/.test(prop)) gap.column = value;\n  });\n  return gap;\n}\n\n/**\n * parse media parameters (for example 'min-width: 500px')\n * @param  {String} params parameter to parse\n * @return {}\n */\nfunction parseMediaParams(params) {\n  if (!params) {\n    return [];\n  }\n  let parsed = parser(params);\n  let prop;\n  let value;\n  parsed.walk(node => {\n    if (node.type === 'word' && /min|max/g.test(node.value)) {\n      prop = node.value;\n    } else if (node.value.includes('px')) {\n      value = parseInt(node.value.replace(/\\D/g, ''));\n    }\n  });\n  return [prop, value];\n}\n\n/**\n * Compare the selectors and decide if we\n * need to inherit gap from compared selector or not.\n * @type {String} selA\n * @type {String} selB\n * @return {Boolean}\n */\nfunction shouldInheritGap(selA, selB) {\n  let result;\n\n  // get arrays of selector split in 3-deep array\n  let splitSelectorArrA = splitSelector(selA);\n  let splitSelectorArrB = splitSelector(selB);\n  if (splitSelectorArrA[0].length < splitSelectorArrB[0].length) {\n    // abort if selectorA has lower descendant specificity then selectorB\n    // (e.g '.grid' and '.hello .world .grid')\n    return false;\n  } else if (splitSelectorArrA[0].length > splitSelectorArrB[0].length) {\n    // if selectorA has higher descendant specificity then selectorB\n    // (e.g '.foo .bar .grid' and '.grid')\n\n    let idx = splitSelectorArrA[0].reduce((res, _ref9, index) => {\n      let [item] = _ref9;\n      let firstSelectorPart = splitSelectorArrB[0][0][0];\n      if (item === firstSelectorPart) {\n        return index;\n      }\n      return false;\n    }, false);\n    if (idx) {\n      result = splitSelectorArrB[0].every((arr, index) => {\n        return arr.every((part, innerIndex) =>\n        // because selectorA has more space elements, we need to slice\n        // selectorA array by 'idx' number to compare them\n        splitSelectorArrA[0].slice(idx)[index][innerIndex] === part);\n      });\n    }\n  } else {\n    // if selectorA has the same descendant specificity as selectorB\n    // this condition covers cases such as: '.grid.foo.bar' and '.grid'\n    result = splitSelectorArrB.some(byCommaArr => {\n      return byCommaArr.every((bySpaceArr, index) => {\n        return bySpaceArr.every((part, innerIndex) => splitSelectorArrA[0][index][innerIndex] === part);\n      });\n    });\n  }\n  return result;\n}\n/**\n * inherit grid gap values from the closest rule above\n * with the same selector\n * @param  {Declaration} decl\n * @param  {Object} gap gap values\n * @return {Object | Boolean} return gap values or false (if not found)\n */\nexports.inheritGridGap = inheritGridGap;\nfunction inheritGridGap(decl, gap) {\n  let rule = decl.parent;\n  let mediaRule = getParentMedia(rule);\n  let root = rule.root();\n\n  // get an array of selector split in 3-deep array\n  let splitSelectorArr = splitSelector(rule.selector);\n\n  // abort if the rule already has gaps\n  if (Object.keys(gap).length > 0) {\n    return false;\n  }\n\n  // e.g ['min-width']\n  let [prop] = parseMediaParams(mediaRule.params);\n  let lastBySpace = splitSelectorArr[0];\n\n  // get escaped value from the selector\n  // if we have '.grid-2.foo.bar' selector, will be '\\.grid\\-2'\n  let escaped = escapeRegexp(lastBySpace[lastBySpace.length - 1][0]);\n  let regexp = new RegExp(`(${escaped}$)|(${escaped}[,.])`);\n\n  // find the closest rule with the same selector\n  let closestRuleGap;\n  root.walkRules(regexp, r => {\n    let gridGap;\n\n    // abort if are checking the same rule\n    if (rule.toString() === r.toString()) {\n      return false;\n    }\n\n    // find grid-gap values\n    r.walkDecls('grid-gap', d => gridGap = getGridGap(d));\n\n    // skip rule without gaps\n    if (!gridGap || Object.keys(gridGap).length === 0) {\n      return true;\n    }\n\n    // skip rules that should not be inherited from\n    if (!shouldInheritGap(rule.selector, r.selector)) {\n      return true;\n    }\n    let media = getParentMedia(r);\n    if (media) {\n      // if we are inside media, we need to check that media props match\n      // e.g ('min-width' === 'min-width')\n      let propToCompare = parseMediaParams(media.params)[0];\n      if (propToCompare === prop) {\n        closestRuleGap = gridGap;\n        return true;\n      }\n    } else {\n      closestRuleGap = gridGap;\n      return true;\n    }\n    return undefined;\n  });\n\n  // if we find the closest gap object\n  if (closestRuleGap && Object.keys(closestRuleGap).length > 0) {\n    return closestRuleGap;\n  }\n  return false;\n}\nexports.warnGridGap = warnGridGap;\nfunction warnGridGap(_ref10) {\n  let {\n    gap,\n    hasColumns,\n    decl,\n    result\n  } = _ref10;\n  let hasBothGaps = gap.row && gap.column;\n  if (!hasColumns && (hasBothGaps || gap.column && !gap.row)) {\n    delete gap.column;\n    decl.warn(result, 'Can not implement grid-gap without grid-template-columns');\n  }\n}\n\n/**\n * normalize the grid-template-rows/columns values\n * @param  {String} str grid-template-rows/columns value\n * @return {Array} normalized array with values\n * @example\n * let normalized = normalizeRowColumn('1fr repeat(2, 20px 50px) 1fr')\n * normalized // <= ['1fr', '20px', '50px', '20px', '50px', '1fr']\n */\nfunction normalizeRowColumn(str) {\n  let normalized = parser(str).nodes.reduce((result, node) => {\n    if (node.type === 'function' && node.value === 'repeat') {\n      let key = 'count';\n      let [count, value] = node.nodes.reduce((acc, n) => {\n        if (n.type === 'word' && key === 'count') {\n          acc[0] = Math.abs(parseInt(n.value));\n          return acc;\n        }\n        if (n.type === 'div' && n.value === ',') {\n          key = 'value';\n          return acc;\n        }\n        if (key === 'value') {\n          acc[1] += parser.stringify(n);\n        }\n        return acc;\n      }, [0, '']);\n      if (count) {\n        for (let i = 0; i < count; i++) {\n          result.push(value);\n        }\n      }\n      return result;\n    }\n    if (node.type === 'space') {\n      return result;\n    }\n    return result.concat(parser.stringify(node));\n  }, []);\n  return normalized;\n}\nexports.autoplaceGridItems = autoplaceGridItems;\n\n/**\n * Autoplace grid items\n * @param {Declaration} decl\n * @param {Result} result\n * @param {Object} gap gap values\n * @param {String} autoflowValue grid-auto-flow value\n * @return {void}\n * @see https://github.com/postcss/autoprefixer/issues/1148\n */\nfunction autoplaceGridItems(decl, result, gap) {\n  let autoflowValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'row';\n  let {\n    parent\n  } = decl;\n  let rowDecl = parent.nodes.find(i => i.prop === 'grid-template-rows');\n  let rows = normalizeRowColumn(rowDecl.value);\n  let columns = normalizeRowColumn(decl.value);\n\n  // Build array of area names with dummy values. If we have 3 columns and\n  // 2 rows, filledRows will be equal to ['1 2 3', '4 5 6']\n  let filledRows = rows.map((_, rowIndex) => {\n    return Array.from({\n      length: columns.length\n    }, (v, k) => k + rowIndex * columns.length + 1).join(' ');\n  });\n  let areas = parseGridAreas({\n    rows: filledRows,\n    gap\n  });\n  let keys = Object.keys(areas);\n  let items = keys.map(i => areas[i]);\n\n  // Change the order of cells if grid-auto-flow value is 'column'\n  if (autoflowValue.includes('column')) {\n    items = items.sort((a, b) => a.column.start - b.column.start);\n  }\n\n  // Insert new rules\n  items.reverse().forEach((item, index) => {\n    let {\n      column,\n      row\n    } = item;\n    let nodeSelector = parent.selectors.map(sel => sel + ` > *:nth-child(${keys.length - index})`).join(', ');\n\n    // create new rule\n    let node = parent.clone().removeAll();\n\n    // change rule selector\n    node.selector = nodeSelector;\n\n    // insert prefixed row/column values\n    node.append({\n      prop: '-ms-grid-row',\n      value: row.start\n    });\n    node.append({\n      prop: '-ms-grid-column',\n      value: column.start\n    });\n\n    // insert rule\n    parent.after(node);\n  });\n  return undefined;\n}","map":{"version":3,"names":["parser","require","list","uniq","escapeRegexp","splitSelector","convert","value","length","parseInt","exports","translate","values","startIndex","endIndex","startValue","endValue","start","spanStart","end","spanEnd","parse","decl","node","current","i","nodes","type","push","insertDecl","prop","parent","some","cloneBefore","toString","prefixTrackProp","_ref","prefix","replace","transformRepeat","_ref2","_ref3","gap","count","size","reduce","result","key","stringify","filter","trim","val","forEach","item","index","join","prefixTrackValue","_ref4","concat","DOTS","track","span","getColumns","line","split","parseGridAreas","_ref5","rows","areas","rowIndex","row","area","columnIndex","test","column","Math","min","max","testTrack","verifyRowSize","parseTemplate","_ref6","gridTemplate","columns","getMSDecls","addRowSpan","arguments","undefined","addColumnSpan","String","getParentMedia","name","changeDuplicateAreaSelectors","ruleSelectors","templateSelectors","map","selector","selectorBySpace","space","selectorByComma","comma","slice","ruleSelector","newSelector","tplSelector","selectorsEqual","ruleA","ruleB","selectors","sel","includes","parseGridTemplatesData","css","parsed","walkDecls","d","rule","media","getGridGap","inheritedGap","inheritGridGap","areaNames","Object","keys","acc","_ref7","idx","allAreas","hasAreas","rules","hasNoDuplicates","r","hasDuplicates","duplicatesFound","duplicateAreaNames","params","updateSpan","areasCount","duplicateRules","insertAreas","isDisabled","gridTemplatesData","rulesToInsert","gridArea","gridAreaRule","hasPrefixedRow","first","gridAreaMedia","gridAreaRuleIndex","data","lastArea","selectorIsComplex","lastRuleIsSet","hasDuplicateName","lastRule","lastRuleIndex","reverse","prepend","assign","raws","between","cloned","clone","removeAll","after","remove","append","p","next","warnMissedAreas","missed","root","e","warn","warnTemplateSelectorNotFound","slicedSelectorArr","str","gridTemplateFound","foundAreaSelector","hasArea","tplSelectorArr","every","warnIfGridRowColumnExists","decls","endsWith","startsWith","testGap","_ref8","parseMediaParams","walk","shouldInheritGap","selA","selB","splitSelectorArrA","splitSelectorArrB","res","_ref9","firstSelectorPart","arr","part","innerIndex","byCommaArr","bySpaceArr","mediaRule","splitSelectorArr","lastBySpace","escaped","regexp","RegExp","closestRuleGap","walkRules","gridGap","propToCompare","warnGridGap","_ref10","hasColumns","hasBothGaps","normalizeRowColumn","normalized","n","abs","autoplaceGridItems","autoflowValue","rowDecl","find","filledRows","_","Array","from","v","k","items","sort","a","b","nodeSelector"],"sources":["/Users/vigneshchowdary/Desktop/untitled folder 5/CryptoBucks-Final-Code/node_modules/autoprefixer/lib/hacks/grid-utils.js"],"sourcesContent":["let parser = require('postcss-value-parser')\nlet list = require('postcss').list\n\nlet uniq = require('../utils').uniq\nlet escapeRegexp = require('../utils').escapeRegexp\nlet splitSelector = require('../utils').splitSelector\n\nfunction convert(value) {\n  if (\n    value &&\n    value.length === 2 &&\n    value[0] === 'span' &&\n    parseInt(value[1], 10) > 0\n  ) {\n    return [false, parseInt(value[1], 10)]\n  }\n\n  if (value && value.length === 1 && parseInt(value[0], 10) > 0) {\n    return [parseInt(value[0], 10), false]\n  }\n\n  return [false, false]\n}\n\nexports.translate = translate\n\nfunction translate(values, startIndex, endIndex) {\n  let startValue = values[startIndex]\n  let endValue = values[endIndex]\n\n  if (!startValue) {\n    return [false, false]\n  }\n\n  let [start, spanStart] = convert(startValue)\n  let [end, spanEnd] = convert(endValue)\n\n  if (start && !endValue) {\n    return [start, false]\n  }\n\n  if (spanStart && end) {\n    return [end - spanStart, spanStart]\n  }\n\n  if (start && spanEnd) {\n    return [start, spanEnd]\n  }\n\n  if (start && end) {\n    return [start, end - start]\n  }\n\n  return [false, false]\n}\n\nexports.parse = parse\n\nfunction parse(decl) {\n  let node = parser(decl.value)\n\n  let values = []\n  let current = 0\n  values[current] = []\n\n  for (let i of node.nodes) {\n    if (i.type === 'div') {\n      current += 1\n      values[current] = []\n    } else if (i.type === 'word') {\n      values[current].push(i.value)\n    }\n  }\n\n  return values\n}\n\nexports.insertDecl = insertDecl\n\nfunction insertDecl(decl, prop, value) {\n  if (value && !decl.parent.some(i => i.prop === `-ms-${prop}`)) {\n    decl.cloneBefore({\n      prop: `-ms-${prop}`,\n      value: value.toString()\n    })\n  }\n}\n\n// Track transforms\n\nexports.prefixTrackProp = prefixTrackProp\n\nfunction prefixTrackProp({ prop, prefix }) {\n  return prefix + prop.replace('template-', '')\n}\n\nfunction transformRepeat({ nodes }, { gap }) {\n  let { count, size } = nodes.reduce(\n    (result, node) => {\n      if (node.type === 'div' && node.value === ',') {\n        result.key = 'size'\n      } else {\n        result[result.key].push(parser.stringify(node))\n      }\n      return result\n    },\n    {\n      key: 'count',\n      size: [],\n      count: []\n    }\n  )\n\n  // insert gap values\n  if (gap) {\n    size = size.filter(i => i.trim())\n    let val = []\n    for (let i = 1; i <= count; i++) {\n      size.forEach((item, index) => {\n        if (index > 0 || i > 1) {\n          val.push(gap)\n        }\n        val.push(item)\n      })\n    }\n\n    return val.join(' ')\n  }\n\n  return `(${size.join('')})[${count.join('')}]`\n}\n\nexports.prefixTrackValue = prefixTrackValue\n\nfunction prefixTrackValue({ value, gap }) {\n  let result = parser(value).nodes.reduce((nodes, node) => {\n    if (node.type === 'function' && node.value === 'repeat') {\n      return nodes.concat({\n        type: 'word',\n        value: transformRepeat(node, { gap })\n      })\n    }\n    if (gap && node.type === 'space') {\n      return nodes.concat(\n        {\n          type: 'space',\n          value: ' '\n        },\n        {\n          type: 'word',\n          value: gap\n        },\n        node\n      )\n    }\n    return nodes.concat(node)\n  }, [])\n\n  return parser.stringify(result)\n}\n\n// Parse grid-template-areas\n\nlet DOTS = /^\\.+$/\n\nfunction track(start, end) {\n  return { start, end, span: end - start }\n}\n\nfunction getColumns(line) {\n  return line.trim().split(/\\s+/g)\n}\n\nexports.parseGridAreas = parseGridAreas\n\nfunction parseGridAreas({ rows, gap }) {\n  return rows.reduce((areas, line, rowIndex) => {\n    if (gap.row) rowIndex *= 2\n\n    if (line.trim() === '') return areas\n\n    getColumns(line).forEach((area, columnIndex) => {\n      if (DOTS.test(area)) return\n\n      if (gap.column) columnIndex *= 2\n\n      if (typeof areas[area] === 'undefined') {\n        areas[area] = {\n          column: track(columnIndex + 1, columnIndex + 2),\n          row: track(rowIndex + 1, rowIndex + 2)\n        }\n      } else {\n        let { column, row } = areas[area]\n\n        column.start = Math.min(column.start, columnIndex + 1)\n        column.end = Math.max(column.end, columnIndex + 2)\n        column.span = column.end - column.start\n\n        row.start = Math.min(row.start, rowIndex + 1)\n        row.end = Math.max(row.end, rowIndex + 2)\n        row.span = row.end - row.start\n      }\n    })\n\n    return areas\n  }, {})\n}\n\n// Parse grid-template\n\nfunction testTrack(node) {\n  return node.type === 'word' && /^\\[.+]$/.test(node.value)\n}\n\nfunction verifyRowSize(result) {\n  if (result.areas.length > result.rows.length) {\n    result.rows.push('auto')\n  }\n  return result\n}\n\nexports.parseTemplate = parseTemplate\n\nfunction parseTemplate({ decl, gap }) {\n  let gridTemplate = parser(decl.value).nodes.reduce(\n    (result, node) => {\n      let { type, value } = node\n\n      if (testTrack(node) || type === 'space') return result\n\n      // area\n      if (type === 'string') {\n        result = verifyRowSize(result)\n        result.areas.push(value)\n      }\n\n      // values and function\n      if (type === 'word' || type === 'function') {\n        result[result.key].push(parser.stringify(node))\n      }\n\n      // divider(/)\n      if (type === 'div' && value === '/') {\n        result.key = 'columns'\n        result = verifyRowSize(result)\n      }\n\n      return result\n    },\n    {\n      key: 'rows',\n      columns: [],\n      rows: [],\n      areas: []\n    }\n  )\n\n  return {\n    areas: parseGridAreas({\n      rows: gridTemplate.areas,\n      gap\n    }),\n    columns: prefixTrackValue({\n      value: gridTemplate.columns.join(' '),\n      gap: gap.column\n    }),\n    rows: prefixTrackValue({\n      value: gridTemplate.rows.join(' '),\n      gap: gap.row\n    })\n  }\n}\n\n// Insert parsed grid areas\n\n/**\n * Get an array of -ms- prefixed props and values\n * @param  {Object} [area] area object with column and row data\n * @param  {Boolean} [addRowSpan] should we add grid-column-row value?\n * @param  {Boolean} [addColumnSpan] should we add grid-column-span value?\n * @return {Array<Object>}\n */\nfunction getMSDecls(area, addRowSpan = false, addColumnSpan = false) {\n  let result = [\n    {\n      prop: '-ms-grid-row',\n      value: String(area.row.start)\n    }\n  ]\n  if (area.row.span > 1 || addRowSpan) {\n    result.push({\n      prop: '-ms-grid-row-span',\n      value: String(area.row.span)\n    })\n  }\n  result.push({\n    prop: '-ms-grid-column',\n    value: String(area.column.start)\n  })\n  if (area.column.span > 1 || addColumnSpan) {\n    result.push({\n      prop: '-ms-grid-column-span',\n      value: String(area.column.span)\n    })\n  }\n  return result\n}\n\nfunction getParentMedia(parent) {\n  if (parent.type === 'atrule' && parent.name === 'media') {\n    return parent\n  }\n  if (!parent.parent) {\n    return false\n  }\n  return getParentMedia(parent.parent)\n}\n\n/**\n * change selectors for rules with duplicate grid-areas.\n * @param  {Array<Rule>} rules\n * @param  {Array<String>} templateSelectors\n * @return {Array<Rule>} rules with changed selectors\n */\nfunction changeDuplicateAreaSelectors(ruleSelectors, templateSelectors) {\n  ruleSelectors = ruleSelectors.map(selector => {\n    let selectorBySpace = list.space(selector)\n    let selectorByComma = list.comma(selector)\n\n    if (selectorBySpace.length > selectorByComma.length) {\n      selector = selectorBySpace.slice(-1).join('')\n    }\n    return selector\n  })\n\n  return ruleSelectors.map(ruleSelector => {\n    let newSelector = templateSelectors.map((tplSelector, index) => {\n      let space = index === 0 ? '' : ' '\n      return `${space}${tplSelector} > ${ruleSelector}`\n    })\n\n    return newSelector\n  })\n}\n\n/**\n * check if selector of rules are equal\n * @param  {Rule} ruleA\n * @param  {Rule} ruleB\n * @return {Boolean}\n */\nfunction selectorsEqual(ruleA, ruleB) {\n  return ruleA.selectors.some(sel => {\n    return ruleB.selectors.includes(sel)\n  })\n}\n\n/**\n * Parse data from all grid-template(-areas) declarations\n * @param  {Root} css css root\n * @return {Object} parsed data\n */\nfunction parseGridTemplatesData(css) {\n  let parsed = []\n\n  // we walk through every grid-template(-areas) declaration and store\n  // data with the same area names inside the item\n  css.walkDecls(/grid-template(-areas)?$/, d => {\n    let rule = d.parent\n    let media = getParentMedia(rule)\n    let gap = getGridGap(d)\n    let inheritedGap = inheritGridGap(d, gap)\n    let { areas } = parseTemplate({ decl: d, gap: inheritedGap || gap })\n    let areaNames = Object.keys(areas)\n\n    // skip node if it doesn't have areas\n    if (areaNames.length === 0) {\n      return true\n    }\n\n    // check parsed array for item that include the same area names\n    // return index of that item\n    let index = parsed.reduce((acc, { allAreas }, idx) => {\n      let hasAreas = allAreas && areaNames.some(area => allAreas.includes(area))\n      return hasAreas ? idx : acc\n    }, null)\n\n    if (index !== null) {\n      // index is found, add the grid-template data to that item\n      let { allAreas, rules } = parsed[index]\n\n      // check if rule has no duplicate area names\n      let hasNoDuplicates = rules.some(r => {\n        return r.hasDuplicates === false && selectorsEqual(r, rule)\n      })\n\n      let duplicatesFound = false\n\n      // check need to gather all duplicate area names\n      let duplicateAreaNames = rules.reduce((acc, r) => {\n        if (!r.params && selectorsEqual(r, rule)) {\n          duplicatesFound = true\n          return r.duplicateAreaNames\n        }\n        if (!duplicatesFound) {\n          areaNames.forEach(name => {\n            if (r.areas[name]) {\n              acc.push(name)\n            }\n          })\n        }\n        return uniq(acc)\n      }, [])\n\n      // update grid-row/column-span values for areas with duplicate\n      // area names. @see #1084 and #1146\n      rules.forEach(r => {\n        areaNames.forEach(name => {\n          let area = r.areas[name]\n          if (area && area.row.span !== areas[name].row.span) {\n            areas[name].row.updateSpan = true\n          }\n\n          if (area && area.column.span !== areas[name].column.span) {\n            areas[name].column.updateSpan = true\n          }\n        })\n      })\n\n      parsed[index].allAreas = uniq([...allAreas, ...areaNames])\n      parsed[index].rules.push({\n        hasDuplicates: !hasNoDuplicates,\n        params: media.params,\n        selectors: rule.selectors,\n        node: rule,\n        duplicateAreaNames,\n        areas\n      })\n    } else {\n      // index is NOT found, push the new item to the parsed array\n      parsed.push({\n        allAreas: areaNames,\n        areasCount: 0,\n        rules: [\n          {\n            hasDuplicates: false,\n            duplicateRules: [],\n            params: media.params,\n            selectors: rule.selectors,\n            node: rule,\n            duplicateAreaNames: [],\n            areas\n          }\n        ]\n      })\n    }\n\n    return undefined\n  })\n\n  return parsed\n}\n\n/**\n * insert prefixed grid-area declarations\n * @param  {Root}  css css root\n * @param  {Function} isDisabled check if the rule is disabled\n * @return {void}\n */\nexports.insertAreas = insertAreas\n\nfunction insertAreas(css, isDisabled) {\n  // parse grid-template declarations\n  let gridTemplatesData = parseGridTemplatesData(css)\n\n  // return undefined if no declarations found\n  if (gridTemplatesData.length === 0) {\n    return undefined\n  }\n\n  // we need to store the rules that we will insert later\n  let rulesToInsert = {}\n\n  css.walkDecls('grid-area', gridArea => {\n    let gridAreaRule = gridArea.parent\n    let hasPrefixedRow = gridAreaRule.first.prop === '-ms-grid-row'\n    let gridAreaMedia = getParentMedia(gridAreaRule)\n\n    if (isDisabled(gridArea)) {\n      return undefined\n    }\n\n    let gridAreaRuleIndex = css.index(gridAreaMedia || gridAreaRule)\n\n    let value = gridArea.value\n    // found the data that matches grid-area identifier\n    let data = gridTemplatesData.filter(d => d.allAreas.includes(value))[0]\n\n    if (!data) {\n      return true\n    }\n\n    let lastArea = data.allAreas[data.allAreas.length - 1]\n    let selectorBySpace = list.space(gridAreaRule.selector)\n    let selectorByComma = list.comma(gridAreaRule.selector)\n    let selectorIsComplex =\n      selectorBySpace.length > 1 &&\n      selectorBySpace.length > selectorByComma.length\n\n    // prevent doubling of prefixes\n    if (hasPrefixedRow) {\n      return false\n    }\n\n    // create the empty object with the key as the last area name\n    // e.g if we have templates with \"a b c\" values, \"c\" will be the last area\n    if (!rulesToInsert[lastArea]) {\n      rulesToInsert[lastArea] = {}\n    }\n\n    let lastRuleIsSet = false\n\n    // walk through every grid-template rule data\n    for (let rule of data.rules) {\n      let area = rule.areas[value]\n      let hasDuplicateName = rule.duplicateAreaNames.includes(value)\n\n      // if we can't find the area name, update lastRule and continue\n      if (!area) {\n        let lastRule = rulesToInsert[lastArea].lastRule\n        let lastRuleIndex\n        if (lastRule) {\n          lastRuleIndex = css.index(lastRule)\n        } else {\n          /* c8 ignore next 2 */\n          lastRuleIndex = -1\n        }\n\n        if (gridAreaRuleIndex > lastRuleIndex) {\n          rulesToInsert[lastArea].lastRule = gridAreaMedia || gridAreaRule\n        }\n        continue\n      }\n\n      // for grid-templates inside media rule we need to create empty\n      // array to push prefixed grid-area rules later\n      if (rule.params && !rulesToInsert[lastArea][rule.params]) {\n        rulesToInsert[lastArea][rule.params] = []\n      }\n\n      if ((!rule.hasDuplicates || !hasDuplicateName) && !rule.params) {\n        // grid-template has no duplicates and not inside media rule\n\n        getMSDecls(area, false, false)\n          .reverse()\n          .forEach(i =>\n            gridAreaRule.prepend(\n              Object.assign(i, {\n                raws: {\n                  between: gridArea.raws.between\n                }\n              })\n            )\n          )\n\n        rulesToInsert[lastArea].lastRule = gridAreaRule\n        lastRuleIsSet = true\n      } else if (rule.hasDuplicates && !rule.params && !selectorIsComplex) {\n        // grid-template has duplicates and not inside media rule\n        let cloned = gridAreaRule.clone()\n        cloned.removeAll()\n\n        getMSDecls(area, area.row.updateSpan, area.column.updateSpan)\n          .reverse()\n          .forEach(i =>\n            cloned.prepend(\n              Object.assign(i, {\n                raws: {\n                  between: gridArea.raws.between\n                }\n              })\n            )\n          )\n\n        cloned.selectors = changeDuplicateAreaSelectors(\n          cloned.selectors,\n          rule.selectors\n        )\n\n        if (rulesToInsert[lastArea].lastRule) {\n          rulesToInsert[lastArea].lastRule.after(cloned)\n        }\n        rulesToInsert[lastArea].lastRule = cloned\n        lastRuleIsSet = true\n      } else if (\n        rule.hasDuplicates &&\n        !rule.params &&\n        selectorIsComplex &&\n        gridAreaRule.selector.includes(rule.selectors[0])\n      ) {\n        // grid-template has duplicates and not inside media rule\n        // and the selector is complex\n        gridAreaRule.walkDecls(/-ms-grid-(row|column)/, d => d.remove())\n        getMSDecls(area, area.row.updateSpan, area.column.updateSpan)\n          .reverse()\n          .forEach(i =>\n            gridAreaRule.prepend(\n              Object.assign(i, {\n                raws: {\n                  between: gridArea.raws.between\n                }\n              })\n            )\n          )\n      } else if (rule.params) {\n        // grid-template is inside media rule\n        // if we're inside media rule, we need to store prefixed rules\n        // inside rulesToInsert object to be able to preserve the order of media\n        // rules and merge them easily\n        let cloned = gridAreaRule.clone()\n        cloned.removeAll()\n\n        getMSDecls(area, area.row.updateSpan, area.column.updateSpan)\n          .reverse()\n          .forEach(i =>\n            cloned.prepend(\n              Object.assign(i, {\n                raws: {\n                  between: gridArea.raws.between\n                }\n              })\n            )\n          )\n\n        if (rule.hasDuplicates && hasDuplicateName) {\n          cloned.selectors = changeDuplicateAreaSelectors(\n            cloned.selectors,\n            rule.selectors\n          )\n        }\n\n        cloned.raws = rule.node.raws\n\n        if (css.index(rule.node.parent) > gridAreaRuleIndex) {\n          // append the prefixed rules right inside media rule\n          // with grid-template\n          rule.node.parent.append(cloned)\n        } else {\n          // store the rule to insert later\n          rulesToInsert[lastArea][rule.params].push(cloned)\n        }\n\n        // set new rule as last rule ONLY if we didn't set lastRule for\n        // this grid-area before\n        if (!lastRuleIsSet) {\n          rulesToInsert[lastArea].lastRule = gridAreaMedia || gridAreaRule\n        }\n      }\n    }\n\n    return undefined\n  })\n\n  // append stored rules inside the media rules\n  Object.keys(rulesToInsert).forEach(area => {\n    let data = rulesToInsert[area]\n    let lastRule = data.lastRule\n    Object.keys(data)\n      .reverse()\n      .filter(p => p !== 'lastRule')\n      .forEach(params => {\n        if (data[params].length > 0 && lastRule) {\n          lastRule.after({ name: 'media', params })\n          lastRule.next().append(data[params])\n        }\n      })\n  })\n\n  return undefined\n}\n\n/**\n * Warn user if grid area identifiers are not found\n * @param  {Object} areas\n * @param  {Declaration} decl\n * @param  {Result} result\n * @return {void}\n */\nexports.warnMissedAreas = warnMissedAreas\n\nfunction warnMissedAreas(areas, decl, result) {\n  let missed = Object.keys(areas)\n\n  decl.root().walkDecls('grid-area', gridArea => {\n    missed = missed.filter(e => e !== gridArea.value)\n  })\n\n  if (missed.length > 0) {\n    decl.warn(result, 'Can not find grid areas: ' + missed.join(', '))\n  }\n\n  return undefined\n}\n\n/**\n * compare selectors with grid-area rule and grid-template rule\n * show warning if grid-template selector is not found\n * (this function used for grid-area rule)\n * @param  {Declaration} decl\n * @param  {Result} result\n * @return {void}\n */\nexports.warnTemplateSelectorNotFound = warnTemplateSelectorNotFound\n\nfunction warnTemplateSelectorNotFound(decl, result) {\n  let rule = decl.parent\n  let root = decl.root()\n  let duplicatesFound = false\n\n  // slice selector array. Remove the last part (for comparison)\n  let slicedSelectorArr = list\n    .space(rule.selector)\n    .filter(str => str !== '>')\n    .slice(0, -1)\n\n  // we need to compare only if selector is complex.\n  // e.g '.grid-cell' is simple, but '.parent > .grid-cell' is complex\n  if (slicedSelectorArr.length > 0) {\n    let gridTemplateFound = false\n    let foundAreaSelector = null\n\n    root.walkDecls(/grid-template(-areas)?$/, d => {\n      let parent = d.parent\n      let templateSelectors = parent.selectors\n\n      let { areas } = parseTemplate({ decl: d, gap: getGridGap(d) })\n      let hasArea = areas[decl.value]\n\n      // find the the matching selectors\n      for (let tplSelector of templateSelectors) {\n        if (gridTemplateFound) {\n          break\n        }\n        let tplSelectorArr = list.space(tplSelector).filter(str => str !== '>')\n\n        gridTemplateFound = tplSelectorArr.every(\n          (item, idx) => item === slicedSelectorArr[idx]\n        )\n      }\n\n      if (gridTemplateFound || !hasArea) {\n        return true\n      }\n\n      if (!foundAreaSelector) {\n        foundAreaSelector = parent.selector\n      }\n\n      // if we found the duplicate area with different selector\n      if (foundAreaSelector && foundAreaSelector !== parent.selector) {\n        duplicatesFound = true\n      }\n\n      return undefined\n    })\n\n    // warn user if we didn't find template\n    if (!gridTemplateFound && duplicatesFound) {\n      decl.warn(\n        result,\n        'Autoprefixer cannot find a grid-template ' +\n          `containing the duplicate grid-area \"${decl.value}\" ` +\n          `with full selector matching: ${slicedSelectorArr.join(' ')}`\n      )\n    }\n  }\n}\n\n/**\n * warn user if both grid-area and grid-(row|column)\n * declarations are present in the same rule\n * @param  {Declaration} decl\n * @param  {Result} result\n * @return {void}\n */\nexports.warnIfGridRowColumnExists = warnIfGridRowColumnExists\n\nfunction warnIfGridRowColumnExists(decl, result) {\n  let rule = decl.parent\n  let decls = []\n  rule.walkDecls(/^grid-(row|column)/, d => {\n    if (\n      !d.prop.endsWith('-end') &&\n      !d.value.startsWith('span') &&\n      !d.prop.endsWith('-gap')\n    ) {\n      decls.push(d)\n    }\n  })\n  if (decls.length > 0) {\n    decls.forEach(d => {\n      d.warn(\n        result,\n        'You already have a grid-area declaration present in the rule. ' +\n          `You should use either grid-area or ${d.prop}, not both`\n      )\n    })\n  }\n\n  return undefined\n}\n\n// Gap utils\n\nexports.getGridGap = getGridGap\n\nfunction getGridGap(decl) {\n  let gap = {}\n\n  // try to find gap\n  let testGap = /^(grid-)?((row|column)-)?gap$/\n  decl.parent.walkDecls(testGap, ({ prop, value }) => {\n    if (/^(grid-)?gap$/.test(prop)) {\n      let [row, , column] = parser(value).nodes\n\n      gap.row = row && parser.stringify(row)\n      gap.column = column ? parser.stringify(column) : gap.row\n    }\n    if (/^(grid-)?row-gap$/.test(prop)) gap.row = value\n    if (/^(grid-)?column-gap$/.test(prop)) gap.column = value\n  })\n\n  return gap\n}\n\n/**\n * parse media parameters (for example 'min-width: 500px')\n * @param  {String} params parameter to parse\n * @return {}\n */\nfunction parseMediaParams(params) {\n  if (!params) {\n    return []\n  }\n  let parsed = parser(params)\n  let prop\n  let value\n\n  parsed.walk(node => {\n    if (node.type === 'word' && /min|max/g.test(node.value)) {\n      prop = node.value\n    } else if (node.value.includes('px')) {\n      value = parseInt(node.value.replace(/\\D/g, ''))\n    }\n  })\n\n  return [prop, value]\n}\n\n/**\n * Compare the selectors and decide if we\n * need to inherit gap from compared selector or not.\n * @type {String} selA\n * @type {String} selB\n * @return {Boolean}\n */\nfunction shouldInheritGap(selA, selB) {\n  let result\n\n  // get arrays of selector split in 3-deep array\n  let splitSelectorArrA = splitSelector(selA)\n  let splitSelectorArrB = splitSelector(selB)\n\n  if (splitSelectorArrA[0].length < splitSelectorArrB[0].length) {\n    // abort if selectorA has lower descendant specificity then selectorB\n    // (e.g '.grid' and '.hello .world .grid')\n    return false\n  } else if (splitSelectorArrA[0].length > splitSelectorArrB[0].length) {\n    // if selectorA has higher descendant specificity then selectorB\n    // (e.g '.foo .bar .grid' and '.grid')\n\n    let idx = splitSelectorArrA[0].reduce((res, [item], index) => {\n      let firstSelectorPart = splitSelectorArrB[0][0][0]\n      if (item === firstSelectorPart) {\n        return index\n      }\n      return false\n    }, false)\n\n    if (idx) {\n      result = splitSelectorArrB[0].every((arr, index) => {\n        return arr.every(\n          (part, innerIndex) =>\n            // because selectorA has more space elements, we need to slice\n            // selectorA array by 'idx' number to compare them\n            splitSelectorArrA[0].slice(idx)[index][innerIndex] === part\n        )\n      })\n    }\n  } else {\n    // if selectorA has the same descendant specificity as selectorB\n    // this condition covers cases such as: '.grid.foo.bar' and '.grid'\n    result = splitSelectorArrB.some(byCommaArr => {\n      return byCommaArr.every((bySpaceArr, index) => {\n        return bySpaceArr.every(\n          (part, innerIndex) => splitSelectorArrA[0][index][innerIndex] === part\n        )\n      })\n    })\n  }\n\n  return result\n}\n/**\n * inherit grid gap values from the closest rule above\n * with the same selector\n * @param  {Declaration} decl\n * @param  {Object} gap gap values\n * @return {Object | Boolean} return gap values or false (if not found)\n */\nexports.inheritGridGap = inheritGridGap\n\nfunction inheritGridGap(decl, gap) {\n  let rule = decl.parent\n  let mediaRule = getParentMedia(rule)\n  let root = rule.root()\n\n  // get an array of selector split in 3-deep array\n  let splitSelectorArr = splitSelector(rule.selector)\n\n  // abort if the rule already has gaps\n  if (Object.keys(gap).length > 0) {\n    return false\n  }\n\n  // e.g ['min-width']\n  let [prop] = parseMediaParams(mediaRule.params)\n\n  let lastBySpace = splitSelectorArr[0]\n\n  // get escaped value from the selector\n  // if we have '.grid-2.foo.bar' selector, will be '\\.grid\\-2'\n  let escaped = escapeRegexp(lastBySpace[lastBySpace.length - 1][0])\n\n  let regexp = new RegExp(`(${escaped}$)|(${escaped}[,.])`)\n\n  // find the closest rule with the same selector\n  let closestRuleGap\n  root.walkRules(regexp, r => {\n    let gridGap\n\n    // abort if are checking the same rule\n    if (rule.toString() === r.toString()) {\n      return false\n    }\n\n    // find grid-gap values\n    r.walkDecls('grid-gap', d => (gridGap = getGridGap(d)))\n\n    // skip rule without gaps\n    if (!gridGap || Object.keys(gridGap).length === 0) {\n      return true\n    }\n\n    // skip rules that should not be inherited from\n    if (!shouldInheritGap(rule.selector, r.selector)) {\n      return true\n    }\n\n    let media = getParentMedia(r)\n    if (media) {\n      // if we are inside media, we need to check that media props match\n      // e.g ('min-width' === 'min-width')\n      let propToCompare = parseMediaParams(media.params)[0]\n      if (propToCompare === prop) {\n        closestRuleGap = gridGap\n        return true\n      }\n    } else {\n      closestRuleGap = gridGap\n      return true\n    }\n\n    return undefined\n  })\n\n  // if we find the closest gap object\n  if (closestRuleGap && Object.keys(closestRuleGap).length > 0) {\n    return closestRuleGap\n  }\n  return false\n}\n\nexports.warnGridGap = warnGridGap\n\nfunction warnGridGap({ gap, hasColumns, decl, result }) {\n  let hasBothGaps = gap.row && gap.column\n  if (!hasColumns && (hasBothGaps || (gap.column && !gap.row))) {\n    delete gap.column\n    decl.warn(\n      result,\n      'Can not implement grid-gap without grid-template-columns'\n    )\n  }\n}\n\n/**\n * normalize the grid-template-rows/columns values\n * @param  {String} str grid-template-rows/columns value\n * @return {Array} normalized array with values\n * @example\n * let normalized = normalizeRowColumn('1fr repeat(2, 20px 50px) 1fr')\n * normalized // <= ['1fr', '20px', '50px', '20px', '50px', '1fr']\n */\nfunction normalizeRowColumn(str) {\n  let normalized = parser(str).nodes.reduce((result, node) => {\n    if (node.type === 'function' && node.value === 'repeat') {\n      let key = 'count'\n\n      let [count, value] = node.nodes.reduce(\n        (acc, n) => {\n          if (n.type === 'word' && key === 'count') {\n            acc[0] = Math.abs(parseInt(n.value))\n            return acc\n          }\n          if (n.type === 'div' && n.value === ',') {\n            key = 'value'\n            return acc\n          }\n          if (key === 'value') {\n            acc[1] += parser.stringify(n)\n          }\n          return acc\n        },\n        [0, '']\n      )\n\n      if (count) {\n        for (let i = 0; i < count; i++) {\n          result.push(value)\n        }\n      }\n\n      return result\n    }\n    if (node.type === 'space') {\n      return result\n    }\n    return result.concat(parser.stringify(node))\n  }, [])\n\n  return normalized\n}\n\nexports.autoplaceGridItems = autoplaceGridItems\n\n/**\n * Autoplace grid items\n * @param {Declaration} decl\n * @param {Result} result\n * @param {Object} gap gap values\n * @param {String} autoflowValue grid-auto-flow value\n * @return {void}\n * @see https://github.com/postcss/autoprefixer/issues/1148\n */\nfunction autoplaceGridItems(decl, result, gap, autoflowValue = 'row') {\n  let { parent } = decl\n\n  let rowDecl = parent.nodes.find(i => i.prop === 'grid-template-rows')\n  let rows = normalizeRowColumn(rowDecl.value)\n  let columns = normalizeRowColumn(decl.value)\n\n  // Build array of area names with dummy values. If we have 3 columns and\n  // 2 rows, filledRows will be equal to ['1 2 3', '4 5 6']\n  let filledRows = rows.map((_, rowIndex) => {\n    return Array.from(\n      { length: columns.length },\n      (v, k) => k + rowIndex * columns.length + 1\n    ).join(' ')\n  })\n\n  let areas = parseGridAreas({ rows: filledRows, gap })\n  let keys = Object.keys(areas)\n  let items = keys.map(i => areas[i])\n\n  // Change the order of cells if grid-auto-flow value is 'column'\n  if (autoflowValue.includes('column')) {\n    items = items.sort((a, b) => a.column.start - b.column.start)\n  }\n\n  // Insert new rules\n  items.reverse().forEach((item, index) => {\n    let { column, row } = item\n    let nodeSelector = parent.selectors\n      .map(sel => sel + ` > *:nth-child(${keys.length - index})`)\n      .join(', ')\n\n    // create new rule\n    let node = parent.clone().removeAll()\n\n    // change rule selector\n    node.selector = nodeSelector\n\n    // insert prefixed row/column values\n    node.append({ prop: '-ms-grid-row', value: row.start })\n    node.append({ prop: '-ms-grid-column', value: column.start })\n\n    // insert rule\n    parent.after(node)\n  })\n\n  return undefined\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}