{"ast":null,"code":"let featureQueries = require('caniuse-lite/data/features/css-featurequeries.js');\nlet feature = require('caniuse-lite/dist/unpacker/feature');\nlet {\n  parse\n} = require('postcss');\nlet Browsers = require('./browsers');\nlet brackets = require('./brackets');\nlet Value = require('./value');\nlet utils = require('./utils');\nlet data = feature(featureQueries);\nlet supported = [];\nfor (let browser in data.stats) {\n  let versions = data.stats[browser];\n  for (let version in versions) {\n    let support = versions[version];\n    if (/y/.test(support)) {\n      supported.push(browser + ' ' + version);\n    }\n  }\n}\nclass Supports {\n  constructor(Prefixes, all) {\n    this.Prefixes = Prefixes;\n    this.all = all;\n  }\n\n  /**\n   * Return prefixer only with @supports supported browsers\n   */\n  prefixer() {\n    if (this.prefixerCache) {\n      return this.prefixerCache;\n    }\n    let filtered = this.all.browsers.selected.filter(i => {\n      return supported.includes(i);\n    });\n    let browsers = new Browsers(this.all.browsers.data, filtered, this.all.options);\n    this.prefixerCache = new this.Prefixes(this.all.data, browsers, this.all.options);\n    return this.prefixerCache;\n  }\n\n  /**\n   * Parse string into declaration property and value\n   */\n  parse(str) {\n    let parts = str.split(':');\n    let prop = parts[0];\n    let value = parts[1];\n    if (!value) value = '';\n    return [prop.trim(), value.trim()];\n  }\n\n  /**\n   * Create virtual rule to process it by prefixer\n   */\n  virtual(str) {\n    let [prop, value] = this.parse(str);\n    let rule = parse('a{}').first;\n    rule.append({\n      prop,\n      value,\n      raws: {\n        before: ''\n      }\n    });\n    return rule;\n  }\n\n  /**\n   * Return array of Declaration with all necessary prefixes\n   */\n  prefixed(str) {\n    let rule = this.virtual(str);\n    if (this.disabled(rule.first)) {\n      return rule.nodes;\n    }\n    let result = {\n      warn: () => null\n    };\n    let prefixer = this.prefixer().add[rule.first.prop];\n    prefixer && prefixer.process && prefixer.process(rule.first, result);\n    for (let decl of rule.nodes) {\n      for (let value of this.prefixer().values('add', rule.first.prop)) {\n        value.process(decl);\n      }\n      Value.save(this.all, decl);\n    }\n    return rule.nodes;\n  }\n\n  /**\n   * Return true if brackets node is \"not\" word\n   */\n  isNot(node) {\n    return typeof node === 'string' && /not\\s*/i.test(node);\n  }\n\n  /**\n   * Return true if brackets node is \"or\" word\n   */\n  isOr(node) {\n    return typeof node === 'string' && /\\s*or\\s*/i.test(node);\n  }\n\n  /**\n   * Return true if brackets node is (prop: value)\n   */\n  isProp(node) {\n    return typeof node === 'object' && node.length === 1 && typeof node[0] === 'string';\n  }\n\n  /**\n   * Return true if prefixed property has no unprefixed\n   */\n  isHack(all, unprefixed) {\n    let check = new RegExp(`(\\\\(|\\\\s)${utils.escapeRegexp(unprefixed)}:`);\n    return !check.test(all);\n  }\n\n  /**\n   * Return true if we need to remove node\n   */\n  toRemove(str, all) {\n    let [prop, value] = this.parse(str);\n    let unprefixed = this.all.unprefixed(prop);\n    let cleaner = this.all.cleaner();\n    if (cleaner.remove[prop] && cleaner.remove[prop].remove && !this.isHack(all, unprefixed)) {\n      return true;\n    }\n    for (let checker of cleaner.values('remove', unprefixed)) {\n      if (checker.check(value)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Remove all unnecessary prefixes\n   */\n  remove(nodes, all) {\n    let i = 0;\n    while (i < nodes.length) {\n      if (!this.isNot(nodes[i - 1]) && this.isProp(nodes[i]) && this.isOr(nodes[i + 1])) {\n        if (this.toRemove(nodes[i][0], all)) {\n          nodes.splice(i, 2);\n          continue;\n        }\n        i += 2;\n        continue;\n      }\n      if (typeof nodes[i] === 'object') {\n        nodes[i] = this.remove(nodes[i], all);\n      }\n      i += 1;\n    }\n    return nodes;\n  }\n\n  /**\n   * Clean brackets with one child\n   */\n  cleanBrackets(nodes) {\n    return nodes.map(i => {\n      if (typeof i !== 'object') {\n        return i;\n      }\n      if (i.length === 1 && typeof i[0] === 'object') {\n        return this.cleanBrackets(i[0]);\n      }\n      return this.cleanBrackets(i);\n    });\n  }\n\n  /**\n   * Add \" or \" between properties and convert it to brackets format\n   */\n  convert(progress) {\n    let result = [''];\n    for (let i of progress) {\n      result.push([`${i.prop}: ${i.value}`]);\n      result.push(' or ');\n    }\n    result[result.length - 1] = '';\n    return result;\n  }\n\n  /**\n   * Compress value functions into a string nodes\n   */\n  normalize(nodes) {\n    if (typeof nodes !== 'object') {\n      return nodes;\n    }\n    nodes = nodes.filter(i => i !== '');\n    if (typeof nodes[0] === 'string') {\n      let firstNode = nodes[0].trim();\n      if (firstNode.includes(':') || firstNode === 'selector' || firstNode === 'not selector') {\n        return [brackets.stringify(nodes)];\n      }\n    }\n    return nodes.map(i => this.normalize(i));\n  }\n\n  /**\n   * Add prefixes\n   */\n  add(nodes, all) {\n    return nodes.map(i => {\n      if (this.isProp(i)) {\n        let prefixed = this.prefixed(i[0]);\n        if (prefixed.length > 1) {\n          return this.convert(prefixed);\n        }\n        return i;\n      }\n      if (typeof i === 'object') {\n        return this.add(i, all);\n      }\n      return i;\n    });\n  }\n\n  /**\n   * Add prefixed declaration\n   */\n  process(rule) {\n    let ast = brackets.parse(rule.params);\n    ast = this.normalize(ast);\n    ast = this.remove(ast, rule.params);\n    ast = this.add(ast, rule.params);\n    ast = this.cleanBrackets(ast);\n    rule.params = brackets.stringify(ast);\n  }\n\n  /**\n   * Check global options\n   */\n  disabled(node) {\n    if (!this.all.options.grid) {\n      if (node.prop === 'display' && node.value.includes('grid')) {\n        return true;\n      }\n      if (node.prop.includes('grid') || node.prop === 'justify-items') {\n        return true;\n      }\n    }\n    if (this.all.options.flexbox === false) {\n      if (node.prop === 'display' && node.value.includes('flex')) {\n        return true;\n      }\n      let other = ['order', 'justify-content', 'align-items', 'align-content'];\n      if (node.prop.includes('flex') || other.includes(node.prop)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\nmodule.exports = Supports;","map":{"version":3,"names":["featureQueries","require","feature","parse","Browsers","brackets","Value","utils","data","supported","browser","stats","versions","version","support","test","push","Supports","constructor","Prefixes","all","prefixer","prefixerCache","filtered","browsers","selected","filter","i","includes","options","str","parts","split","prop","value","trim","virtual","rule","first","append","raws","before","prefixed","disabled","nodes","result","warn","add","process","decl","values","save","isNot","node","isOr","isProp","length","isHack","unprefixed","check","RegExp","escapeRegexp","toRemove","cleaner","remove","checker","splice","cleanBrackets","map","convert","progress","normalize","firstNode","stringify","ast","params","grid","flexbox","other","module","exports"],"sources":["/Users/vigneshchowdary/Desktop/gta-final/node_modules/autoprefixer/lib/supports.js"],"sourcesContent":["let featureQueries = require('caniuse-lite/data/features/css-featurequeries.js')\nlet feature = require('caniuse-lite/dist/unpacker/feature')\nlet { parse } = require('postcss')\n\nlet Browsers = require('./browsers')\nlet brackets = require('./brackets')\nlet Value = require('./value')\nlet utils = require('./utils')\n\nlet data = feature(featureQueries)\n\nlet supported = []\nfor (let browser in data.stats) {\n  let versions = data.stats[browser]\n  for (let version in versions) {\n    let support = versions[version]\n    if (/y/.test(support)) {\n      supported.push(browser + ' ' + version)\n    }\n  }\n}\n\nclass Supports {\n  constructor(Prefixes, all) {\n    this.Prefixes = Prefixes\n    this.all = all\n  }\n\n  /**\n   * Return prefixer only with @supports supported browsers\n   */\n  prefixer() {\n    if (this.prefixerCache) {\n      return this.prefixerCache\n    }\n\n    let filtered = this.all.browsers.selected.filter(i => {\n      return supported.includes(i)\n    })\n\n    let browsers = new Browsers(\n      this.all.browsers.data,\n      filtered,\n      this.all.options\n    )\n    this.prefixerCache = new this.Prefixes(\n      this.all.data,\n      browsers,\n      this.all.options\n    )\n    return this.prefixerCache\n  }\n\n  /**\n   * Parse string into declaration property and value\n   */\n  parse(str) {\n    let parts = str.split(':')\n    let prop = parts[0]\n    let value = parts[1]\n    if (!value) value = ''\n    return [prop.trim(), value.trim()]\n  }\n\n  /**\n   * Create virtual rule to process it by prefixer\n   */\n  virtual(str) {\n    let [prop, value] = this.parse(str)\n    let rule = parse('a{}').first\n    rule.append({ prop, value, raws: { before: '' } })\n    return rule\n  }\n\n  /**\n   * Return array of Declaration with all necessary prefixes\n   */\n  prefixed(str) {\n    let rule = this.virtual(str)\n    if (this.disabled(rule.first)) {\n      return rule.nodes\n    }\n\n    let result = { warn: () => null }\n\n    let prefixer = this.prefixer().add[rule.first.prop]\n    prefixer && prefixer.process && prefixer.process(rule.first, result)\n\n    for (let decl of rule.nodes) {\n      for (let value of this.prefixer().values('add', rule.first.prop)) {\n        value.process(decl)\n      }\n      Value.save(this.all, decl)\n    }\n\n    return rule.nodes\n  }\n\n  /**\n   * Return true if brackets node is \"not\" word\n   */\n  isNot(node) {\n    return typeof node === 'string' && /not\\s*/i.test(node)\n  }\n\n  /**\n   * Return true if brackets node is \"or\" word\n   */\n  isOr(node) {\n    return typeof node === 'string' && /\\s*or\\s*/i.test(node)\n  }\n\n  /**\n   * Return true if brackets node is (prop: value)\n   */\n  isProp(node) {\n    return (\n      typeof node === 'object' &&\n      node.length === 1 &&\n      typeof node[0] === 'string'\n    )\n  }\n\n  /**\n   * Return true if prefixed property has no unprefixed\n   */\n  isHack(all, unprefixed) {\n    let check = new RegExp(`(\\\\(|\\\\s)${utils.escapeRegexp(unprefixed)}:`)\n    return !check.test(all)\n  }\n\n  /**\n   * Return true if we need to remove node\n   */\n  toRemove(str, all) {\n    let [prop, value] = this.parse(str)\n    let unprefixed = this.all.unprefixed(prop)\n\n    let cleaner = this.all.cleaner()\n\n    if (\n      cleaner.remove[prop] &&\n      cleaner.remove[prop].remove &&\n      !this.isHack(all, unprefixed)\n    ) {\n      return true\n    }\n\n    for (let checker of cleaner.values('remove', unprefixed)) {\n      if (checker.check(value)) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  /**\n   * Remove all unnecessary prefixes\n   */\n  remove(nodes, all) {\n    let i = 0\n    while (i < nodes.length) {\n      if (\n        !this.isNot(nodes[i - 1]) &&\n        this.isProp(nodes[i]) &&\n        this.isOr(nodes[i + 1])\n      ) {\n        if (this.toRemove(nodes[i][0], all)) {\n          nodes.splice(i, 2)\n          continue\n        }\n\n        i += 2\n        continue\n      }\n\n      if (typeof nodes[i] === 'object') {\n        nodes[i] = this.remove(nodes[i], all)\n      }\n\n      i += 1\n    }\n    return nodes\n  }\n\n  /**\n   * Clean brackets with one child\n   */\n  cleanBrackets(nodes) {\n    return nodes.map(i => {\n      if (typeof i !== 'object') {\n        return i\n      }\n\n      if (i.length === 1 && typeof i[0] === 'object') {\n        return this.cleanBrackets(i[0])\n      }\n\n      return this.cleanBrackets(i)\n    })\n  }\n\n  /**\n   * Add \" or \" between properties and convert it to brackets format\n   */\n  convert(progress) {\n    let result = ['']\n    for (let i of progress) {\n      result.push([`${i.prop}: ${i.value}`])\n      result.push(' or ')\n    }\n    result[result.length - 1] = ''\n    return result\n  }\n\n  /**\n   * Compress value functions into a string nodes\n   */\n  normalize(nodes) {\n    if (typeof nodes !== 'object') {\n      return nodes\n    }\n\n    nodes = nodes.filter(i => i !== '')\n\n    if (typeof nodes[0] === 'string') {\n      let firstNode = nodes[0].trim()\n\n      if (\n        firstNode.includes(':') ||\n        firstNode === 'selector' ||\n        firstNode === 'not selector'\n      ) {\n        return [brackets.stringify(nodes)]\n      }\n    }\n    return nodes.map(i => this.normalize(i))\n  }\n\n  /**\n   * Add prefixes\n   */\n  add(nodes, all) {\n    return nodes.map(i => {\n      if (this.isProp(i)) {\n        let prefixed = this.prefixed(i[0])\n        if (prefixed.length > 1) {\n          return this.convert(prefixed)\n        }\n\n        return i\n      }\n\n      if (typeof i === 'object') {\n        return this.add(i, all)\n      }\n\n      return i\n    })\n  }\n\n  /**\n   * Add prefixed declaration\n   */\n  process(rule) {\n    let ast = brackets.parse(rule.params)\n    ast = this.normalize(ast)\n    ast = this.remove(ast, rule.params)\n    ast = this.add(ast, rule.params)\n    ast = this.cleanBrackets(ast)\n    rule.params = brackets.stringify(ast)\n  }\n\n  /**\n   * Check global options\n   */\n  disabled(node) {\n    if (!this.all.options.grid) {\n      if (node.prop === 'display' && node.value.includes('grid')) {\n        return true\n      }\n      if (node.prop.includes('grid') || node.prop === 'justify-items') {\n        return true\n      }\n    }\n\n    if (this.all.options.flexbox === false) {\n      if (node.prop === 'display' && node.value.includes('flex')) {\n        return true\n      }\n      let other = ['order', 'justify-content', 'align-items', 'align-content']\n      if (node.prop.includes('flex') || other.includes(node.prop)) {\n        return true\n      }\n    }\n\n    return false\n  }\n}\n\nmodule.exports = Supports\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}