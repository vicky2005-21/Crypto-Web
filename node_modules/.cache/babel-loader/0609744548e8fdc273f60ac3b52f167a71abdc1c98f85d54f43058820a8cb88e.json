{"ast":null,"code":"let {\n  list\n} = require('postcss');\nlet OldSelector = require('./old-selector');\nlet Prefixer = require('./prefixer');\nlet Browsers = require('./browsers');\nlet utils = require('./utils');\nclass Selector extends Prefixer {\n  constructor(name, prefixes, all) {\n    super(name, prefixes, all);\n    this.regexpCache = new Map();\n  }\n\n  /**\n   * Is rule selectors need to be prefixed\n   */\n  check(rule) {\n    if (rule.selector.includes(this.name)) {\n      return !!rule.selector.match(this.regexp());\n    }\n    return false;\n  }\n\n  /**\n   * Return prefixed version of selector\n   */\n  prefixed(prefix) {\n    return this.name.replace(/^(\\W*)/, `$1${prefix}`);\n  }\n\n  /**\n   * Lazy loadRegExp for name\n   */\n  regexp(prefix) {\n    if (!this.regexpCache.has(prefix)) {\n      let name = prefix ? this.prefixed(prefix) : this.name;\n      this.regexpCache.set(prefix, new RegExp(`(^|[^:\"'=])${utils.escapeRegexp(name)}`, 'gi'));\n    }\n    return this.regexpCache.get(prefix);\n  }\n\n  /**\n   * All possible prefixes\n   */\n  possible() {\n    return Browsers.prefixes();\n  }\n\n  /**\n   * Return all possible selector prefixes\n   */\n  prefixeds(rule) {\n    if (rule._autoprefixerPrefixeds) {\n      if (rule._autoprefixerPrefixeds[this.name]) {\n        return rule._autoprefixerPrefixeds;\n      }\n    } else {\n      rule._autoprefixerPrefixeds = {};\n    }\n    let prefixeds = {};\n    if (rule.selector.includes(',')) {\n      let ruleParts = list.comma(rule.selector);\n      let toProcess = ruleParts.filter(el => el.includes(this.name));\n      for (let prefix of this.possible()) {\n        prefixeds[prefix] = toProcess.map(el => this.replace(el, prefix)).join(', ');\n      }\n    } else {\n      for (let prefix of this.possible()) {\n        prefixeds[prefix] = this.replace(rule.selector, prefix);\n      }\n    }\n    rule._autoprefixerPrefixeds[this.name] = prefixeds;\n    return rule._autoprefixerPrefixeds;\n  }\n\n  /**\n   * Is rule already prefixed before\n   */\n  already(rule, prefixeds, prefix) {\n    let index = rule.parent.index(rule) - 1;\n    while (index >= 0) {\n      let before = rule.parent.nodes[index];\n      if (before.type !== 'rule') {\n        return false;\n      }\n      let some = false;\n      for (let key in prefixeds[this.name]) {\n        let prefixed = prefixeds[this.name][key];\n        if (before.selector === prefixed) {\n          if (prefix === key) {\n            return true;\n          } else {\n            some = true;\n            break;\n          }\n        }\n      }\n      if (!some) {\n        return false;\n      }\n      index -= 1;\n    }\n    return false;\n  }\n\n  /**\n   * Replace selectors by prefixed one\n   */\n  replace(selector, prefix) {\n    return selector.replace(this.regexp(), `$1${this.prefixed(prefix)}`);\n  }\n\n  /**\n   * Clone and add prefixes for at-rule\n   */\n  add(rule, prefix) {\n    let prefixeds = this.prefixeds(rule);\n    if (this.already(rule, prefixeds, prefix)) {\n      return;\n    }\n    let cloned = this.clone(rule, {\n      selector: prefixeds[this.name][prefix]\n    });\n    rule.parent.insertBefore(rule, cloned);\n  }\n\n  /**\n   * Return function to fast find prefixed selector\n   */\n  old(prefix) {\n    return new OldSelector(this, prefix);\n  }\n}\nmodule.exports = Selector;","map":{"version":3,"names":["list","require","OldSelector","Prefixer","Browsers","utils","Selector","constructor","name","prefixes","all","regexpCache","Map","check","rule","selector","includes","match","regexp","prefixed","prefix","replace","has","set","RegExp","escapeRegexp","get","possible","prefixeds","_autoprefixerPrefixeds","ruleParts","comma","toProcess","filter","el","map","join","already","index","parent","before","nodes","type","some","key","add","cloned","clone","insertBefore","old","module","exports"],"sources":["/Users/vigneshchowdary/Desktop/untitled folder 5/CryptoBucks-Final-Code/node_modules/autoprefixer/lib/selector.js"],"sourcesContent":["let { list } = require('postcss')\n\nlet OldSelector = require('./old-selector')\nlet Prefixer = require('./prefixer')\nlet Browsers = require('./browsers')\nlet utils = require('./utils')\n\nclass Selector extends Prefixer {\n  constructor(name, prefixes, all) {\n    super(name, prefixes, all)\n    this.regexpCache = new Map()\n  }\n\n  /**\n   * Is rule selectors need to be prefixed\n   */\n  check(rule) {\n    if (rule.selector.includes(this.name)) {\n      return !!rule.selector.match(this.regexp())\n    }\n\n    return false\n  }\n\n  /**\n   * Return prefixed version of selector\n   */\n  prefixed(prefix) {\n    return this.name.replace(/^(\\W*)/, `$1${prefix}`)\n  }\n\n  /**\n   * Lazy loadRegExp for name\n   */\n  regexp(prefix) {\n    if (!this.regexpCache.has(prefix)) {\n      let name = prefix ? this.prefixed(prefix) : this.name\n      this.regexpCache.set(\n        prefix,\n        new RegExp(`(^|[^:\"'=])${utils.escapeRegexp(name)}`, 'gi')\n      )\n    }\n\n    return this.regexpCache.get(prefix)\n  }\n\n  /**\n   * All possible prefixes\n   */\n  possible() {\n    return Browsers.prefixes()\n  }\n\n  /**\n   * Return all possible selector prefixes\n   */\n  prefixeds(rule) {\n    if (rule._autoprefixerPrefixeds) {\n      if (rule._autoprefixerPrefixeds[this.name]) {\n        return rule._autoprefixerPrefixeds\n      }\n    } else {\n      rule._autoprefixerPrefixeds = {}\n    }\n\n    let prefixeds = {}\n    if (rule.selector.includes(',')) {\n      let ruleParts = list.comma(rule.selector)\n      let toProcess = ruleParts.filter(el => el.includes(this.name))\n\n      for (let prefix of this.possible()) {\n        prefixeds[prefix] = toProcess\n          .map(el => this.replace(el, prefix))\n          .join(', ')\n      }\n    } else {\n      for (let prefix of this.possible()) {\n        prefixeds[prefix] = this.replace(rule.selector, prefix)\n      }\n    }\n\n    rule._autoprefixerPrefixeds[this.name] = prefixeds\n    return rule._autoprefixerPrefixeds\n  }\n\n  /**\n   * Is rule already prefixed before\n   */\n  already(rule, prefixeds, prefix) {\n    let index = rule.parent.index(rule) - 1\n\n    while (index >= 0) {\n      let before = rule.parent.nodes[index]\n\n      if (before.type !== 'rule') {\n        return false\n      }\n\n      let some = false\n      for (let key in prefixeds[this.name]) {\n        let prefixed = prefixeds[this.name][key]\n        if (before.selector === prefixed) {\n          if (prefix === key) {\n            return true\n          } else {\n            some = true\n            break\n          }\n        }\n      }\n      if (!some) {\n        return false\n      }\n\n      index -= 1\n    }\n\n    return false\n  }\n\n  /**\n   * Replace selectors by prefixed one\n   */\n  replace(selector, prefix) {\n    return selector.replace(this.regexp(), `$1${this.prefixed(prefix)}`)\n  }\n\n  /**\n   * Clone and add prefixes for at-rule\n   */\n  add(rule, prefix) {\n    let prefixeds = this.prefixeds(rule)\n\n    if (this.already(rule, prefixeds, prefix)) {\n      return\n    }\n\n    let cloned = this.clone(rule, { selector: prefixeds[this.name][prefix] })\n    rule.parent.insertBefore(rule, cloned)\n  }\n\n  /**\n   * Return function to fast find prefixed selector\n   */\n  old(prefix) {\n    return new OldSelector(this, prefix)\n  }\n}\n\nmodule.exports = Selector\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}